// Generated by gourd (version 0.1dev)
// Generated at 2015/10/25 01:00:16 (+0800)
// Note: If you want to re-generate this file in the future,
//       do not change it.

package oauth2

import (
	"github.com/gourd/service"
	"github.com/gourd/service/upperio"
	"net/http"

	"encoding/base64"
	"github.com/satori/go.uuid"
	"strings"

	"log"
	"upper.io/db"
)

func init() {
	// define service provider with proxy
	service.Providers.DefineFunc("User", func(r *http.Request) (s service.Service, err error) {
		return GetUserService(r)
	})
}

// GetUserService provides raw UserService
func GetUserService(r *http.Request) (s *UserService, err error) {

	// obtain database
	db, err := upperio.Open(r, "default")
	if err != nil {
		return
	}

	// define service and return
	s = &UserService{db}
	return
}

// UserService serves generic CURD for type User
// Generated by gourd CLI tool
type UserService struct {
	Db db.Database
}

// Create a User in the database, of the parent
func (s *UserService) Create(
	cond service.Conds, ep service.EntityPtr) (err error) {

	// get collection
	coll, err := s.Coll()
	if err != nil {
		return
	}

	// apply random uuid string to string id

	uid := uuid.NewV4()
	e := ep.(*User)
	e.Id = strings.TrimRight(base64.URLEncoding.EncodeToString(uid[:]), "=")

	//TODO: convert cond into parentkey and
	//      enforce to the entity

	// add the entity to collection

	_, err = coll.Append(ep)

	if err != nil {
		log.Printf("Error creating User: %s", err.Error())
		err = service.ErrorInternal
		return
	}

	return
}

// Search a User by its condition(s)
func (s *UserService) Search(
	q service.Query) (result service.Result, err error) {

	// get collection
	coll, err := s.Coll()
	if err != nil {
		return
	}

	// retrieve entities by given query conditions
	var res db.Result
	conds := upperio.Conds(q.GetConds())
	if conds == nil {
		res = coll.Find()
	} else {
		res = coll.Find(conds)
	}

	// handle paging
	if q.GetOffset() != 0 {
		res = res.Skip(uint(q.GetOffset()))
	}
	if q.GetLimit() != 0 {
		res = res.Limit(uint(q.GetLimit()))
	}

	result = upperio.NewResult(res)
	return
}

// One returns the first User matches condition(s)
func (s *UserService) One(
	c service.Conds, ep service.EntityPtr) (err error) {

	// retrieve results from database
	l := &[]User{}
	q := service.NewQuery().SetConds(c)
	res, err := s.Search(q)
	if err != nil {
		return
	}

	// dump results into pointer of map / struct
	err = res.All(l)
	if err != nil {
		return
	}

	// if not found, report
	if len(*l) == 0 {
		err = service.ErrorNotFound
		return
	}

	// assign the value of given point
	// to the first retrieved value
	(*ep.(*User)) = (*l)[0]
	return nil
}

// Update User on condition(s)
func (s *UserService) Update(
	c service.Conds, ep service.EntityPtr) (err error) {

	// get collection
	coll, err := s.Coll()
	if err != nil {
		return
	}

	// get by condition and ignore the error
	cond, _ := c.GetMap()
	res := coll.Find(db.Cond(cond))

	// update the matched entities
	err = res.Update(ep)
	if err != nil {
		log.Printf("Error updating User: %s", err.Error())
		err = service.ErrorInternal
	}
	return
}

// Delete User on condition(s)
func (s *UserService) Delete(
	c service.Conds) (err error) {

	// get collection
	coll, err := s.Coll()
	if err != nil {
		return
	}

	// get by condition and ignore the error
	cond, _ := c.GetMap()
	res := coll.Find(db.Cond(cond))

	// remove the matched entities
	err = res.Remove()
	if err != nil {
		log.Printf("Error deleting User: %s", err.Error())
		err = service.ErrorInternal
	}
	return nil
}

// AllocEntity allocate memory for an entity
func (s *UserService) AllocEntity() service.EntityPtr {
	return &User{}
}

// AllocEntityList allocate memory for an entity list
func (s *UserService) AllocEntityList() service.EntityListPtr {
	return &[]User{}
}

// Len inspect the length of an entity list
func (s *UserService) Len(pl service.EntityListPtr) int64 {
	el := pl.(*[]User)
	return int64(len(*el))
}

// Coll return the raw upper.io collection
func (s *UserService) Coll() (coll db.Collection, err error) {
	// get raw collection
	coll, err = s.Db.Collection("user")
	if err != nil {
		log.Printf("Error connecting collection user: %s",
			err.Error())
		err = service.ErrorInternal
	}
	return
}

// Close the database session that User is using
func (s *UserService) Close() error {
	return s.Db.Close()
}
